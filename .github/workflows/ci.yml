# This starter workflow is for a CMake project running on multiple platforms.
# There is a different starter workflow if you just want a single platform.
# See: https://github.com/actions/starter-workflows/blob/main/ci/cmake-single-platform.yml
name: SecureStorage Build on multiple platforms

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  # Existing trigger for actual releases
  create: # This is effectively the same as `on: { push: { tags: [ 'v*' ] } }` for triggering on new tags
    tags:
      - 'v*' # Trigger actual release for tags like v1.0.0
  # New manual trigger for testing release steps
  workflow_dispatch:
    inputs:
      test_tag_name:
        description: 'Simulate a tag name for testing (e.g., v1.0.0-test). If empty, a default test tag will be used.'
        required: false
        type: string
      is_production_release_run:
        description: 'DANGER: If true, this manual run will attempt a full production release. Default is false (test/dry-run mode).'
        required: true
        default: 'false' # Important: default to false for safety
        type: boolean

jobs:
  build:
    runs-on: ${{ matrix.os }}

    strategy:
      # Set fail-fast to false to ensure that feedback is delivered for all matrix combinations. [cite: 4]
      # Consider changing this to true when your workflow is stable. [cite: 4]
      fail-fast: false

      # Set up a matrix to run the following 3 configurations:
      # 1. <Windows, Release, latest MSVC compiler toolchain on the default runner image, default generator>
      # 2. <Linux, Release, latest GCC compiler toolchain on the default runner image, default generator>
      # 3. <Linux, Release, latest Clang compiler toolchain on the default runner image, default generator>
      #
      # To add more build types (Release, Debug, RelWithDebInfo, etc.) customize the build_type list. [cite: 5]
      matrix:
        os: [ubuntu-latest, windows-latest]
        build_type: [Release] #
        c_compiler: [gcc, clang, cl]
        include:
          - os: windows-latest
            c_compiler: cl
            cpp_compiler: cl
          - os: ubuntu-latest
            c_compiler: gcc
            cpp_compiler: g++
          - os: ubuntu-latest
            c_compiler: clang
            cpp_compiler: clang++
        exclude:
          - os: windows-latest
            c_compiler: gcc
          - os: windows-latest #
            c_compiler: clang
          - os: ubuntu-latest
            c_compiler: cl

    steps:
    - uses: actions/checkout@v4

    - name: Set reusable strings
      # Turn repeated input strings (such as the build output directory) into step outputs. [cite: 8]
      # These step outputs can be used throughout the workflow file. [cite: 9]
      id: strings #
      shell: bash
      run: | #
        echo "build-output-dir=${{ github.workspace }}/build" >> "$GITHUB_OUTPUT"

    - name: Configure CMake
      # Configure CMake in a 'build' subdirectory. [cite: 11]
      # `CMAKE_BUILD_TYPE` is only required if you are using a single-configuration generator such as make. [cite: 12]
      # See https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html?highlight=cmake_build_type [cite: 12]
      run: >
        cmake -B ${{ steps.strings.outputs.build-output-dir }}
        -DCMAKE_CXX_COMPILER=${{ matrix.cpp_compiler }}
        -DCMAKE_C_COMPILER=${{ matrix.c_compiler }}
        -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
        -S ${{ github.workspace }} #

    - name: Build
      # Build your program with the given configuration. [cite: 13]
      # Note that --config is needed because the default Windows generator is a multi-config generator (Visual Studio generator). [cite: 14]
      run: cmake --build ${{ steps.strings.outputs.build-output-dir }} --config ${{ matrix.build_type }} #

    - name: Test
      working-directory: ${{ steps.strings.outputs.build-output-dir }}
      # Execute tests defined by the CMake configuration. [cite: 15]
      # Note that --build-config is needed because the default Windows generator is a multi-config generator (Visual Studio generator). [cite: 16]
      # See https://cmake.org/cmake/help/latest/manual/ctest.1.html for more detail [cite: 16]
      run: ctest --build-config ${{ matrix.build_type }} --output-on-failure

    - name: Install project
      run: cmake --install ${{ steps.strings.outputs.build-output-dir }} --prefix ${{ github.workspace }}/build/install

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: build-${{ matrix.os }}-${{ matrix.c_compiler }}-${{ matrix.build_type }}
        path: ${{ github.workspace }}/build/install/ #

  build-docs:
    name: Build Doxygen Documentation # [cite: 17]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive' # Checkout submodules if your project uses them

      - name: Install Doxygen and Graphviz
        run: | # [cite: 18]
          sudo apt-get update
          sudo apt-get install -y doxygen graphviz

      - name: Configure CMake
        run: cmake -B ${{ github.workspace }}/build -S ${{ github.workspace }} -DCMAKE_BUILD_TYPE=Release

      - name: Build Doxygen target
        run: cmake --build ${{ github.workspace }}/build --target doxygen

      - name: Upload Doxygen HTML
        uses: actions/upload-artifact@v4
        with:
          name: doxygen-html-docs # [cite: 19]
          path: ${{ github.workspace }}/build/docs/html/ # Adjust path if your Doxyfile output is different [cite: 20]

  release:
    name: Create Release and Upload Assets
    # Trigger conditions:
    # 1. Actual tag creation starting with 'v'
    # 2. Manual workflow_dispatch
    if: (github.event_name == 'create' && startsWith(github.ref, 'refs/tags/v')) || github.event_name == 'workflow_dispatch'
    needs: [build, build-docs] # [cite: 20]
    runs-on: ubuntu-latest # [cite: 20]
    permissions:
      contents: write # Required to create a release and upload assets [cite: 20]
    outputs: # Define outputs for potential use in later jobs or for summary
      release_tag: ${{ env.RELEASE_TAG }}
      is_dry_run: ${{ env.IS_DRY_RUN }}
      upload_url: ${{ steps.create_github_release.outputs.upload_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive' # [cite: 21]
          fetch-depth: 0 # Important for getting tags for versioning

      - name: Set up MSYS2 (for zip on Linux runner)
        if: runner.os == 'Linux' # [cite: 21]
        uses: msys2/setup-msys2@v2
        with: # [cite: 21]
          msystem: MINGW64 # or UCRT64 [cite: 22]
          update: true
          install: zip # [cite: 22]

      # Download all build artifacts
      - name: Download Linux GCC Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: build-ubuntu-latest-gcc-Release # Match artifact name from build job [cite: 22]
          path: build-artifacts/linux-gcc

      - name: Download Linux Clang Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: build-ubuntu-latest-clang-Release # Match artifact name from build job [cite: 23]
          path: build-artifacts/linux-clang # [cite: 23]

      - name: Download Windows MSVC Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: build-windows-latest-cl-Release # Match artifact name from build job [cite: 24]
          path: build-artifacts/windows-msvc

      - name: Download Doxygen HTML Docs
        uses: actions/download-artifact@v4
        with:
          name: doxygen-html-docs # [cite: 24]
          path: doxygen-docs

      - name: Determine Release Tag and Dry Run Status
        id: release_vars
        shell: bash # Ensure bash is used for consistency in script
        run: |
          IS_DRY_RUN_VALUE="true"
          TAG_NAME=""

          if [ "${{ github.event_name }}" == "create" ] && [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            TAG_NAME="${{ github.ref_name }}"
            # For a pure 'create' event (not a dispatch), assume it's production.
            IS_DRY_RUN_VALUE="false" 
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG_NAME="${{ github.event.inputs.test_tag_name }}"
            if [ -z "$TAG_NAME" ]; then
              TAG_NAME="v0.0.0-testdispatch-$(date +%s)" # Add timestamp for uniqueness
            fi
            if [ "${{ github.event.inputs.is_production_release_run }}" == "true" ]; then
              IS_DRY_RUN_VALUE="false"
            else
              IS_DRY_RUN_VALUE="true"
            fi
          else
            # Fallback for other triggers (should not happen with current job 'if' condition)
            TAG_NAME="v0.0.0-snapshot-$(date +%s)"
            echo "Warning: Release job triggered by unexpected event: ${{ github.event_name }}"
          fi
          
          echo "Determined tag: $TAG_NAME"
          echo "Is dry run? $IS_DRY_RUN_VALUE"
          echo "RELEASE_TAG=$TAG_NAME" >> $GITHUB_ENV
          echo "IS_DRY_RUN=$IS_DRY_RUN_VALUE" >> $GITHUB_ENV

      - name: Create Release Packages
        shell: bash # Ensure bash is used
        run: |
          echo "Packaging for tag: ${{ env.RELEASE_TAG }}"
          # Create a directory for release assets [cite: 25]
          mkdir -p release_assets #

          # Package Doxygen docs [cite: 25]
          zip -r release_assets/SecureStorage-docs-${{ env.RELEASE_TAG }}.zip doxygen-docs/ # [cite: 26]
          echo "Packaged Doxygen documentation." # [cite: 26]

          # Package Linux GCC build [cite: 26]
          if [ -d "build-artifacts/linux-gcc" ] && [ "$(ls -A build-artifacts/linux-gcc)" ]; then # [cite: 27]
            tar -czvf release_assets/SecureStorage-linux-gcc-${{ env.RELEASE_TAG }}.tar.gz -C build-artifacts/linux-gcc . # [cite: 28]
            echo "Packaged Linux GCC build." # [cite: 28]
          else
            echo "Warning: Linux GCC build artifact not found or is empty in build-artifacts/linux-gcc/." # [cite: 29]
          fi

          # Package Linux Clang build [cite: 30]
          if [ -d "build-artifacts/linux-clang" ] && [ "$(ls -A build-artifacts/linux-clang)" ]; then # [cite: 30]
            tar -czvf release_assets/SecureStorage-linux-clang-${{ env.RELEASE_TAG }}.tar.gz -C build-artifacts/linux-clang . # [cite: 31]
            echo "Packaged Linux Clang build." # [cite: 31]
          else
            echo "Warning: Linux Clang build artifact not found or is empty in build-artifacts/linux-clang/." # [cite: 32]
          fi

          # Package Windows MSVC build [cite: 33]
          if [ -d "build-artifacts/windows-msvc" ] && [ "$(ls -A build-artifacts/windows-msvc)" ]; then # [cite: 33]
            (cd build-artifacts/windows-msvc && zip -r ../../release_assets/SecureStorage-windows-msvc-${{ env.RELEASE_TAG }}.zip .) # [cite: 34]
            echo "Packaged Windows MSVC build." # [cite: 34]
          else
            echo "Warning: Windows MSVC build artifact not found or is empty in build-artifacts/windows-msvc/." # [cite: 35]
          fi
          echo "--- Contents of release_assets ---"
          ls -R release_assets # [cite: 36]
          echo "--- End of release_assets ---"


      - name: Upload Packaged Artifacts (for Test/Dry Run)
        if: env.IS_DRY_RUN == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: test-release-packages-${{ env.RELEASE_TAG }}
          path: ./release_assets/*

      - name: Create GitHub Release (Production Run Only)
        if: env.IS_DRY_RUN == 'false' && startsWith(env.RELEASE_TAG, 'v') # Ensure it's a 'v' tag
        id: create_github_release 
        uses: actions/create-release@v1 #
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.RELEASE_TAG }} # Use the determined tag
          release_name: Release ${{ env.RELEASE_TAG }}
          body: | # [cite: 36]
            Release of version ${{ env.RELEASE_TAG }}.
            Please find the attached assets for different platforms and the API documentation. # [cite: 37]
          draft: false # [cite: 38]
          prerelease: ${{ contains(env.RELEASE_TAG, '-beta') || contains(env.RELEASE_TAG, '-rc') || contains(env.RELEASE_TAG, '-alpha') || contains(env.RELEASE_TAG, '-test') }} # Also consider test tags as prerelease [cite: 39]

      - name: Upload Release Assets (Production Run Only)
        # This step uploads all assets found in release_assets if it's a production run
        if: env.IS_DRY_RUN == 'false' && steps.create_github_release.outputs.upload_url
        shell: bash
        run: |
          for asset_path in ./release_assets/*; do
            if [ -f "$asset_path" ]; then
              asset_name=$(basename "$asset_path")
              echo "Uploading $asset_name..."
              gh release upload ${{ env.RELEASE_TAG }} "$asset_path" --clobber
            else
              echo "Skipping $asset_path, not a file."
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }} # gh cli needs repo context

      - name: Log Final Release Mode
        shell: bash
        run: |
          echo "Job triggered by: ${{ github.event_name }}"
          echo "Tag for this run: ${{ env.RELEASE_TAG }}"
          echo "Is this a dry/test run? ${{ env.IS_DRY_RUN }}"
          if [[ "${{ env.IS_DRY_RUN }}" == "false" && "${{ steps.create_github_release.outputs.upload_url }}" != "" ]]; then
            echo "A production GitHub Release was created/attempted: ${{ steps.create_github_release.outputs.html_url }}"
          elif [[ "${{ env.IS_DRY_RUN }}" == "true" ]]; then
            echo "This was a test run. Packaged artifacts were uploaded as workflow artifacts (if successful)."
          else
            echo "This was not a production release run (either dry run or create_github_release step was skipped)."
          fi

# The comments about needing to upload build artifacts were already addressed by your existing `build` job. [cite: 43, 44, 45, 46, 47]
